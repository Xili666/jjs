# Java #

1. HashMap
    1. java7中HashMap使用拉链法解决冲突,在hash碰撞严重的时候会导致个别位置链表长度过长,严重影响性能
    2. java8中当每个桶的链表长度超过8之后,会将链表转化成红黑树,从而提升增删改查的速度

2. HashMap死锁
    1. HashMap是线程不安全的
    2. HashMap的初始容量大小为16,如果超过的话需要增大Hash表的尺寸,需要将Hash表的数据都重算一遍(reHash)
    3. 如果一个线程在reHash的时候另一个线程突然闯入,也reHash一次,可能就会导致链表出现环形链表,导致死循环
    4. 可以使用HashTable,但是HashTable锁定的是整个表,效率较低,推荐使用ConcurrentHashMap,可以保证读的时候不加锁,写的时候锁粒度尽可能小

3. 局部内部类是放在代码块或方法中的,不能有访问控制修饰符,且不能用static

4. [变量设置为null之后,引用并不会释放(*如果时可达对象*)](Reference.java)

5. java的四种引用类型
    1. 强引用,  只要引用存在, 就不会gc
    2. 软引用,  非必须引用，内存溢出之前进行回收, 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据
    3. 弱引用,  第二次垃圾回收时回收, 弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null, 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记
    4. 虚引用,  虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。 虚引用主要用于检测对象是否已经从内存中删除

6. 关于clone()
    1. clone() 是一个protect方法,所以只能在类内部中调用
    2. [Cloneable](Clone.java)接口只是起一个标识作用,如果调用clone()方法必须要有,否则会抛出CloneNotSupportedException
    3. 基本数据类型能自动实现深度克隆

7. 包装类和String都是final类
8. [String的细节研究](StringLearn.java)
    1. 使用intern()会在字符常量区寻找字符串的引用,然后返回,没有会创建一个
    2. 有变量时的字符串`+`和`"a" + "b"`不是同一个引用,前者放在堆区