# Java虚拟机 #

![JVM 结构图](./image/jvm.png)

1. 整个JVM分四个部分:
    1. ClassLoader 类加载器
        - 加载符合文件结构的class文件
    2. Execution Engine 执行引擎
        - 也叫解释器,负责解释命令,提交操作系统执行
    3. Native Interface 本地接口
        - 融合不同的编程语言,企业中使用比较少
    4. Runtime data area 运行数据区
        - 代码被加载到这里开始运行

2. JVM 加载类
    1. 装载
    2. 连接
        1. 验证
        2. 准备
        3. [解释]
    3. 初始化

3. JVM加载class文件的原理机制
    遇到一个新的类时,首先会到方法区去找class文件,如果没有找到就会去硬盘中找class文件,找到后会返回,将class文件加载到方法区中.在类加载的时候,静态成员变量会被分配到方法区的静态区域,非静态成员变量分配到非静态区域,然后开始给静态成员变量初始化,赋默认值,赋值完成根据静态成员变量书写的位置赋显示值,然后执行静态代码,当所有的静态代码执行完成,才算加载完成

4. java创建对象
    1. 用new创建的对象在堆区
    2. 函数中的临时变量在栈区
    3. Java中的字符串在字符常量区

5. 垃圾回收
    1. 老生代一般用标记,新生代一般用复制
    2. CMS
    3. G1

6. loadClass 不初始化
7. forName 初始化

8. JVM的编码是Unicode,不选择具体的编码,java在读取字符流时有隐式转换
9. InputStreamReader和OutputStreamWriter作为适配类,承担了编码转换任务
10. JVM垃圾收集器在收集一个对象之前, 一般要求程序调用适当的方法释放资源, 在没有明确释放资源的情况下,Java提供`finalize()`来作为默认机制
11. 所有的对象都在堆上分配.
12. 内存的分配由程序完成,内存的释放由GC完成
13. 内存泄漏, 对象可达, 且不会再使用
14. 常见典型的内存泄露
    1. 全局集合, 常见解决方案: 周期性执行清除任务
    2. 缓存, 常用解决方案:
        1. 检查结果是否再缓存中, 如果在, 就返回结果
        2. 如果结果不再缓存中,就进行计算
        3. 如果缓存所占的空间过大,就移除缓存最久的结果
        4. 将计算出来的结果添加到缓存中,以便以后对该操作的调度可以使用
        解决缓存问题的另一种方法:
            使用java.lang.ref.SoftReference类跟踪缓存中的对象

15. 从抽象的JVM角度看, Java的内存结构包含:
    1. 栈区: 由编译器自动分配释放,具体方法结束后,系统自动释放JVM内存资源
                作用: 保存基本数据类型的值,保存类的实例(对堆对象的引用), 也可以用来保存加载方法时的帧
    2. 堆区: 一般由程序员分配释放,JVM会gc这个区域
                作用: 用来存放动态产生的数据, 包括new出来的实例,字符数组等.
                注意: 创建出来的对象只包含各自的成员变量,不包括成员方法,
                    因为同一个类的对象拥有各自的成员变量,存储在各自的堆中, 但是他们共享该类的方法.
    3. 代码区: 存放程序中方法的二进制代码, 多个对象共享一个代码空间区域
    4. 数据区: 用来存放static定义的静态成员
    5. 常量池: JVM为每个已加载的类型维护一个常量池, 常量池就是这个类型用到的常量的有序集合.包括直接常量(基本类型,String)和对其它类型.方法.字段的符号引用.
            池中的数据和数组一样通过索引访问.
            常量池存于堆中.