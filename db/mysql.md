# 索引 #

1. MySQL的最左优先原则
   索引的第一个字段出现在查询的where中就会走索引,全部出现就会走复合索引
2. 锁的行为和顺序是和存储引擎相关的.
3. 死锁的产生原因:
    1. 真正的数据冲突
    2. 存储引擎的实现方式
4. InnoDB处理死锁的方法: *将持有最少行级排它锁的事务回滚*.
5. 索引失效场景
    1. like % 模糊查询, 比如`%a`和`%a%`, 但是`a%`可以走索引
    2. 查询使用`is not null` 或者 `<>`不等于比较符
    3. 对索引列使用运算/函数 `year(time)`
    4. 复合索引的第一列不在where中

6. InnoDB 和 MyISAM
   |          | InnoDB        | MyISAM   |
   | :------: | :------------ | :------- |
   | 事务处理 | 事务安全      | 不支持   |
   | 锁机制   | 行级锁        | 表级锁   |
   | 操作     | insert,update | select   |
   | 查询行数 | 遍历全表      | 简单读取 |
   | 外键支持 | 支持          | 不支持   |

7. 为什么MyISAM的查询比InnoDB快
    1. 数据块, InnoDB要缓存, MyISAM只缓存索引块
    2. InnoDB寻址要到文件的块再到行, MyIASM记录的是文件的offset,定位更快
    3. InnoDB要维护MVCC一致

8. DBMS中事务有四个特性:
    1. 持久性   -- 恢复管理子系统
    2. 一致性   -- 并发控制子系统
    3. 原子性   -- 完整性管理子系统
    4. 隔离性   -- 安全控制管理子系统

9. 索引使用B+树而不用红黑树:
    1. 更少的查找次数
    2. 利用磁盘预读特性

10. 主从复制
    1. binlog线程: 负责将主服务器上的数据更改写入二进制日志中
    2. I/O线程: 负责将主服务器上读取二进制日志, 并写入从服务器的重放日志中
    3. SQL线程: 负责读取重放日志, 并重放其中的SQL语句

11. 读写分离
    1. 主从服务器负责各自的读和写, 极大程度缓解了锁的争用
    2. 从服务器可以使用MyISAM, 提高查询性能以及节约系统开销
    3. 增加冗余, 提高可用性