# 索引 #

1. MySQL的最左优先原则
   索引的第一个字段出现在查询的where中就会走索引,全部出现就会走复合索引
2. 锁的行为和顺序是和存储引擎相关的.
3. 死锁的产生原因:
    1. 真正的数据冲突
    2. 存储引擎的实现方式
4. InnoDB处理死锁的方法: *将持有最少行级排它锁的事务回滚*.
5. 索引失效场景
    1. like % 模糊查询, 比如`%a`和`%a%`, 但是`a%`可以走索引
    2. 查询使用`is not null` 或者 `<>`不等于比较符
    3. 对索引列使用运算/函数 `year(time)`
    4. 复合索引的第一列不在where中

6. InnoDB 和 MyISAM
   |          | InnoDB        | MyISAM   |
   | :------: | :------------ | :------- |
   | 事务处理 | 事务安全      | 不支持   |
   | 锁机制   | 行级锁        | 表级锁   |
   | 操作     | insert,update | select   |
   | 查询行数 | 遍历全表      | 简单读取 |
   | 外键支持 | 支持          | 不支持   |

7. 为什么MyISAM的查询比InnoDB快
    1. 数据块, InnoDB要缓存, MyISAM只缓存索引块
    2. InnoDB寻址要到文件的块再到行, MyIASM记录的是文件的offset,定位更快
    3. InnoDB要维护MVCC一致